// Type Definitions

type ServerId : 1..3;
type ClientId : 1..3;
type RequestId : 0..99;
type View: 1..9;

type us: 0..10000000;
type ms: 0..10000;

type NodeId : 1..3;

type MasterState : either {
  Self {

  },
  Other {
    masterId: ServerId,
    timeoutAt: Time,
  }
}

type Entry : record {
  clientId: ClientId,
  requestId: RequestId,
  // actual request omitted
}

type Index: 1..10;
type Log: Vector<Entry>[Index];

type Server : record {
  timeoutAt: Time,
  view: View,
  stateMachine: Array<RequestId>[ClientId],
  log: Log,
  logIndex: Index,
  master: MasterState,
};

type Client : record {
  requestId: RequestId,
  masterId: ServerId,
  timeoutAt: Time,
  waiting: Boolean
}

type Payload : either {
  ClientResponse {
    requestId: RequestId,
    success: either {
      Successful,
      Unsuccessful {try: ServerId},
    }
  },
  ClientRequest {requestId: RequestId}
}

type Packet : record {
  sentAt: Time,
  sentBy : NodeId,
  arriveBy: Time,
  arriveAt: NodeId,
  payload: Payload,

};

// Protocol State

var servers: Array<Server>[ServerId];
var clients: Array<Client>[ClientId];
var network: Set<Packet>[0..20];

var clientTimeoutMin : us = 100000;
var clientTimeoutMax : us = 200000;
var clientRetry : us = 100000;
var netDelayMin : us = 5000;
var netDelayMax : us = 10000;
var FailureTimer : us = 30000;

// Useful functions

function getMasterId(view: View) -> ServerId {
 return view % size(servers); // FIX
}

function makeClientTimeout() -> Time {
  return later(urandomRange(clientTimeoutMin, clientTimeoutMax));
}

function send(to: NodeId, from: NodeId, p: Payload) {
  push(network, Packet {
    sentBy: from,
    sentAt: later(0),
    arriveAt: to,
    arriveBy: later(urandomRange(netDelayMin, netDelayMax)),
    payload: p,
  });
}

function init() {
  for client in clients {
    client.timeoutAt = makeClientTimeout();
    client.masterId = 1;
    client.requestId = 1;
  }
  for serverId, server in servers {
    var masterId : ServerId = getMasterId(server.view);
    if masterId==serverId {
      server.master = Self {};
    } else {
      server.master = Other {masterId: masterId, timeoutAt: later(FailureTimer)};
    }
  }

}

// Initialization
init();


// State Transitions
rule newRequest for clientId, client in clients {
  if past(client.timeoutAt) {
    if client.waiting {
      client.masterId = client.masterId + 1;
    } else {
      client.waiting = True;
    }
    send(client.masterId, clientId, ClientRequest {requestId: client.requestId});
    client.timeoutAt = later(clientRetry);
    }
}

rule handleMessage for msg in network {
  if past(msg.arriveBy) {
    remove(network,msg);
    match msg.payload {
      ClientRequest(data) {
        match servers[msg.arriveAt].master {
          Self {
            servers[msg.arriveAt].stateMachine[msg.sentBy] = data.requestId;
            push(servers[msg.arriveAt].log,
              Entry {clientId:msg.sentBy, requestId:data.requestId});
            servers[msg.arriveAt].logIndex += 1;
            send(
              msg.sentBy,
              msg.arriveAt,
              ClientResponse {requestId: data.requestId, success:Successful});
          }
          Other(masterData) {
            send(
              msg.sentBy,
              msg.arriveAt,
              ClientResponse {requestId: data.requestId, success:Unsuccessful {try:masterData.masterId}});
          }
        }

      }
      ClientResponse(data) {
        if clients[msg.arriveAt].waiting &&
            data.requestId==clients[msg.arriveAt].requestId {
              match data.success {
                Successful {
                  clients[msg.arriveAt].requestId = clients[msg.arriveAt].requestId + 1;
                  clients[msg.arriveAt].waiting = False;
                  clients[msg.arriveAt].timeoutAt = makeClientTimeout();
                }
                Unsuccessful(hint) {
                  clients[msg.arriveAt].masterId = hint.try;
                  send(clients[msg.arriveAt].masterId, msg.arriveAt, ClientRequest {requestId: data.requestId});
                  clients[msg.arriveAt].timeoutAt = later(clientRetry);
                }
              }

            }

      }
    }
  }
}
