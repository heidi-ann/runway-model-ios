// Type Definitions

type ServerId : 1..3;
type ClientId : 1..3;
type RequestId : 0..99;

type us: 0..10000000;
type ms: 0..10000;

type NodeId : 1..3;

type Server : record {
  timeoutAt: Time,
  requestId: RequestId,
  stateMachine: Array<RequestId>[ClientId]
};

type Client : record {
  requestId: RequestId,
  masterId: ServerId,
  timeoutAt: Time,
  waiting: Boolean
}

type Payload : either {
  ClientResponse {requestId: RequestId},
  ClientRequest {requestId: RequestId}
}

type Packet : record {
  sentAt: Time,
  sentBy : NodeId,
  arriveBy: Time,
  arriveAt: NodeId,
  payload: Payload,

};

// Protocol State

var servers: Array<Server>[ServerId];
var clients: Array<Client>[ClientId];
var network: Set<Packet>[0..20];

var clientTimeoutMin : us = 100000;
var clientTimeoutMax : us = 200000;
var clientRetry : us = 100000;
var netDelayMin : us = 5000;
var netDelayMax : us = 10000;

// Useful functions

function makeClientTimeout() -> Time {
  return later(urandomRange(clientTimeoutMin, clientTimeoutMax));
}

function send(to: NodeId, from: NodeId, p: Payload) {
  push(network, Packet {
    sentBy: from,
    sentAt: later(0),
    arriveAt: to,
    arriveBy: later(urandomRange(netDelayMin, netDelayMax)),
    payload: p,
  });
}

function init() {
  for client in clients {
    client.timeoutAt = makeClientTimeout();
    client.masterId = 1;
    client.requestId = 1;
  }

}

// Initialization
init();


// State Transitions
rule newRequest for clientId, client in clients {
  if past(client.timeoutAt) {
    if client.waiting {
      client.masterId = client.masterId + 1;
    } else {
      client.waiting = True;
    }
    send(client.masterId, clientId, ClientRequest {requestId: client.requestId});
    client.timeoutAt = later(clientRetry);
    }
}

rule handleMessage for msg in network {
  if past(msg.arriveBy) {
    remove(network,msg);
    match msg.payload {
      ClientRequest(data) {
        servers[msg.arriveAt].requestId = data.requestId;
        servers[msg.arriveAt].stateMachine[msg.sentBy] = data.requestId;
        send(
          msg.arriveAt,
          msg.sentBy,
          ClientResponse {requestId: data.requestId});
      }
      ClientResponse(data) {
        if clients[msg.arriveAt].waiting &&
            data.requestId==clients[msg.arriveAt].requestId {
              clients[msg.arriveAt].requestId = clients[msg.arriveAt].requestId + 1;
              clients[msg.arriveAt].waiting = False;
              clients[msg.arriveAt].timeoutAt = makeClientTimeout();
            }

      }
    }
  }
}
