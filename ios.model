// Type Definitions

type ServerId : 1..5;
type ServerNum: 0..5;
type ClientId : 1..2;
type RequestId : 0..99;
type View: 1..9;

type us: 0..10000000;
type ms: 0..10000;

type NodeId : 1..5;

type Request: record {
  clientId: ClientId,
  requestId: RequestId,
  // actual request omitted
}

type Entry: record  {
  view: View,
  committed: Boolean,
  request: Request,
}
type Index: 1..10;
type Log: Vector<Entry>[Index];

type CoordinatorState : record {
  request: Request,
  prepare: ServerNum,
  commit: ServerNum,
}

type MasterState : either {
  Unknown {},
  Self {},
  Other {
    masterId: ServerId,
    timeoutAt: Time,
  }
}

type ServerMem: record {
  logIndex: Index, //next free index
  commitIndex: Index,
  stateMachine: Array<RequestId>[ClientId],
  master: MasterState,
  coordinator: Vector<CoordinatorState>[Index]
}

type ServerDisk : record {
  view: View,
  log: Log,
};

type Client : record {
  requestId: RequestId,
  masterId: ServerId,
  timeoutAt: Time,
  waiting: Boolean
}

type Payload : either {
  ClientResponse {
    requestId: RequestId,
    success: either {
      Successful,
      Unsuccessful {try: ServerId},
    }
  },
  ClientRequest {
    requestId: RequestId,
  },
  PrepareRequest {
    index: Index,
    request: Request,
  },
  PrepareResponse {
    index: Index,
    success: Boolean,
  },
  CommitRequest {
    index: Index,
    request: Request,
  },
  CommitResponse {
    index: Index,
    success: Boolean,
  },
  CoordinateRequest {
    index: Index,
    request: Request,
  },
  CoordinateResponse {
    success: Boolean,
  },
}

type Packet : record {
  sentAt: Time,
  sentBy : NodeId,
  arriveBy: Time,
  arriveAt: NodeId,
  payload: Payload,

};

type Status: either {
  Online,
  Offline,
};

// Protocol State

var serversMem: Array<ServerMem>[ServerId];
var serversDisk: Array<ServerDisk>[ServerId];
var serverStatus: Array<Status>[ServerId];
var clients: Array<Client>[ClientId];
var network: Set<Packet>[0..20];

var clientTimeoutMin : us = 100000;
var clientTimeoutMax : us = 200000;
var clientRetry : us = 100000;
var netDelayMin : us = 5000;
var netDelayMax : us = 10000;
var FailureTimer : us = 30000;

var majority:ServerNum = (size(serversMem)/2) +1;

// Useful functions

function getMasterId(view: View) -> ServerId {
 return view % size(serversMem); // FIX
}

function makeClientTimeout() -> Time {
  return later(urandomRange(clientTimeoutMin, clientTimeoutMax));
}

function sendAll(from: NodeId, p: Payload) {
  for serverId, server in serversMem {
    if serverId != from {
      send(serverId, from, p);
    }
  }
}

function sendAllBut(from: NodeId, but: NodeId, p: Payload) {
  for serverId, server in serversMem {
    if serverId != from && serverId != but{
      send(serverId, from, p);
    }
  }
}

function send(to: NodeId, from: NodeId, p: Payload) {
  push(network, Packet {
    sentBy: from,
    sentAt: later(0),
    arriveAt: to,
    arriveBy: later(urandomRange(netDelayMin, netDelayMax)),
    payload: p,
  });
}

function ready(msg: Packet) -> Boolean {
  if past(msg.arriveBy) {
    remove(network,msg);
    return (serverStatus[msg.arriveAt]==Online);
  }
  return False;
}

function init() {
  for client in clients {
    client.timeoutAt = makeClientTimeout();
    client.masterId = 1;
    client.requestId = 1;
  }
  for id, server in serversDisk {
    var masterId : ServerId = getMasterId(server.view);
    if masterId==id {
      serversMem[id].master = Self {};
    } else {
      serversMem[id].master = Other {masterId: masterId, timeoutAt: later(FailureTimer)};
    }
  }

}

function stop(id: ServerId) {
  var cleanServer: ServerMem;
  serversMem[id] = cleanServer;
}

function restart(id: ServerId) {
  serversMem[id].master = Other {masterId: getMasterId(serversDisk[id].view), timeoutAt: later(FailureTimer)};
  serversMem[id].logIndex = size(serversDisk[id].log)+1;
}

// Initialization
init();


// Internal state Transitions
rule newRequest for clientId, client in clients {
  if past(client.timeoutAt) && (client.requestId<=3) {
    if client.waiting {
      client.masterId = client.masterId + 1;
    } else {
      client.waiting = True;
    }
    send(client.masterId, clientId, ClientRequest {requestId: client.requestId});
    client.timeoutAt = later(clientRetry);
    }
}

rule handleClientRequest for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      ClientRequest(data) {
        match serversMem[msg.arriveAt].master {
          Self(masterState) {
              var request: Request = Request {clientId:msg.sentBy, requestId:data.requestId};
              var index: Index = serversMem[msg.arriveAt].logIndex;
              serversMem[msg.arriveAt].logIndex += 1;
              push(serversDisk[msg.arriveAt].log,
                Entry{view: serversDisk[msg.arriveAt].view, committed:False, request:request});
              send(
                msg.arriveAt+1,
                msg.arriveAt,
                CoordinateRequest {index: index, request: request});

          }
          Other(masterData) {
            send(
              msg.sentBy,
              msg.arriveAt,
              ClientResponse {requestId: data.requestId, success:Unsuccessful {try:masterData.masterId}});
          }
          default {}
        }
      remove(network,msg);
    }
  default {}
  }
}
}

rule handleClientResponse for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      ClientResponse(data) {
        if clients[msg.arriveAt].waiting &&
            data.requestId==clients[msg.arriveAt].requestId {
              match data.success {
                Successful {
                  clients[msg.arriveAt].requestId = clients[msg.arriveAt].requestId + 1;
                  clients[msg.arriveAt].waiting = False;
                  clients[msg.arriveAt].timeoutAt = makeClientTimeout();
                }
                Unsuccessful(hint) {
                  clients[msg.arriveAt].masterId = hint.try;
                  send(clients[msg.arriveAt].masterId, msg.arriveAt, ClientRequest {requestId: data.requestId});
                  clients[msg.arriveAt].timeoutAt = later(clientRetry);
                }
              }
            }
        remove(network,msg);
      }
    default {}
    }
  }
}

rule handlePrepareRequest for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      PrepareRequest(data) {
        push(serversDisk[msg.arriveAt].log, Entry{request:data.request,committed:False});
        serversMem[msg.arriveAt].logIndex += 1;
        send(
          msg.sentBy,
          msg.arriveAt,
          PrepareResponse {index: data.index, success:True});
        remove(network,msg);
        }
    default {}
    }
  }
}

rule handlePrepareResponse for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      PrepareResponse(data) {
        serversMem[msg.arriveAt].coordinator[data.index].prepare += 1;
        if serversMem[msg.arriveAt].coordinator[data.index].prepare==majority {
          var request:Request = serversMem[msg.arriveAt].coordinator[data.index].request;
          var entry:Entry = Entry {view: serversDisk[msg.arriveAt].view, committed:True, request:request};
          serversDisk[msg.arriveAt].log[data.index] = entry;
          // check for outstanding entries
          var index:Index = serversMem[msg.arriveAt].commitIndex;
          while index < serversMem[msg.arriveAt].logIndex {
            if serversDisk[msg.arriveAt].log[index].committed {
              var commitRequest: Request = serversDisk[msg.arriveAt].log[index].request;
              serversMem[msg.arriveAt].stateMachine[commitRequest.clientId] = commitRequest.requestId;
              serversMem[msg.arriveAt].commitIndex = index;
              index += 1;
              send(
                commitRequest.clientId,
                msg.arriveAt,
                ClientResponse {requestId: commitRequest.requestId, success: Successful});
            }
            else {break;}
          }
          serversMem[msg.arriveAt].coordinator[data.index].commit += 1;
          sendAll(
            msg.arriveAt,
            CommitRequest{index:data.index,request:request});
        }
      remove(network,msg);
    }
    default {}
    }
  }
}

rule handleCommitRequest for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      CommitRequest(data) {
        serversDisk[msg.arriveAt].log[data.index] =
          Entry {view: serversDisk[msg.arriveAt].view,committed:True, request:data.request};
        var index:Index = serversMem[msg.arriveAt].commitIndex;
        while index < serversMem[msg.arriveAt].logIndex {
          if serversDisk[msg.arriveAt].log[index].committed {
            var request: Request = serversDisk[msg.arriveAt].log[index].request;
            serversMem[msg.arriveAt].stateMachine[request.clientId] = request.requestId;
            serversMem[msg.arriveAt].commitIndex = index;
            index += 1;
          }
          else {break;}
        }
        send(
          msg.sentBy,
          msg.arriveAt,
          CommitResponse {index: data.index, success:(serversMem[msg.arriveAt].commitIndex>=data.index) });
        remove(network,msg);
      }
    default {}
    }
  }
}

rule handleCommitResponse for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      CommitResponse(data) {
        serversMem[msg.arriveAt].coordinator[data.index].commit += 1;
        remove(network,msg);
      }
    default {}
    }
  }
}

rule handleCoordinateRequest for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online {
    match msg.payload {
      CoordinateRequest(data) {
        // replicate locally
        serversMem[msg.arriveAt].logIndex += 1; // TODO: FIX ASSUMPTION
        push(serversDisk[msg.arriveAt].log,
          Entry{view: serversDisk[msg.arriveAt].view, committed:False, request:data.request});
        // start prepare phase
        push(serversMem[msg.arriveAt].coordinator,
           CoordinatorState{request:data.request, prepare: 2, commit:0});
        sendAllBut(
          msg.arriveAt,
          msg.sentBy,
          PrepareRequest {index: data.index, request: data.request});
        // reply to master
        send(
          msg.sentBy,
          msg.arriveAt,
          CoordinateResponse {success:True});
        remove(network,msg);
      }
    default {}
    }
  }
}

rule handleCoordinateResponse for msg in network {
  if past(msg.arriveBy) && serverStatus[msg.arriveAt]==Online{
    match msg.payload {
      CoordinateResponse {
        // do nothing
        remove(network,msg);
      }
    default {}
    }
  }
}

// External state Transitions

external nodeFailure for id, status in serverStatus {
  status = Offline;
  stop(id);
}

external nodeRecovery for id, status in serverStatus {
  status = Online;
  restart(id);
}
